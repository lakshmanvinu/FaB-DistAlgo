# -*- generated by 1.1.0b13 -*-
import da
PatternExpr_210 = da.pat.ConstantPattern('consensus')
PatternExpr_214 = da.pat.BoundPattern('_BoundPattern216_')
PatternExpr_409 = da.pat.ConstantPattern('done')
PatternExpr_413 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.ConstantPattern('done')])
PatternExpr_635 = da.pat.ConstantPattern('done')
PatternExpr_639 = da.pat.BoundPattern('_BoundPattern640_')
PatternExpr_641 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern647_')]), da.pat.ConstantPattern('done')])
_config_object = {}
# import fab
import time
import sys
import resource
import math
from prettytable import PrettyTable

class Controller(da.DistProcess):
    """
    This is the Controller process for the Fast Byzantine Consensus to test performance of the implementation
    """
    def __init__(self, procimpl, forwarder, **props):
        super().__init__(procimpl, forwarder, **props)
        self._ControllerReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ControllerReceivedEvent_0', PatternExpr_210, sources=[PatternExpr_214], destinations=None, timestamps=None, record_history=None, handlers=[self._Controller_handler_209]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ControllerReceivedEvent_1', PatternExpr_409, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self):
        """
        Setup method for Performance verification process.

        :return: None
        :rtype: None
        """
        super().setup(**rest_670)
        '\n        Setup method for Performance verification process.\n\n        :return: None\n        :rtype: None\n        '
        self._state.startTime = None
        self._state.endTime = None
        self._state.startData = None
        self._state.endData = None

    def run(self):
        self._state.startTime = time.perf_counter()
        self._state.startData = resource.getrusage(resource.RUSAGE_SELF)
        super()._label('_st_label_406', block=False)
        _st_label_406 = 0
        while (_st_label_406 == 0):
            _st_label_406 += 1
            if PatternExpr_413.match_iter(self._ControllerReceivedEvent_1, SELF_ID=self._id):
                _st_label_406 += 1
            else:
                super()._label('_st_label_406', block=True)
                _st_label_406 -= 1

    def printMetrics(self):
        """
        Method to print performance metrics for the algorithm run.

        :return: message to be sent
        :rtype: tuple
        """
        self._state.endTime = time.perf_counter()
        self._state.endData = resource.getrusage(resource.RUSAGE_SELF)
        userTime = (getattr(self._state.endData, 'ru_utime') - getattr(self._state.startData, 'ru_utime'))
        systemTime = (getattr(self._state.endData, 'ru_stime') - getattr(self._state.startData, 'ru_stime'))
        processTime = round((userTime + systemTime), 8)
        memoryUsage = self._state.endData.ru_maxrss
        elapsedTime = round((self._state.endTime - self._state.startTime), 4)
        print('\n')
        print(('-' * 43))
        print(('#' * 10), 'Performance Evaluation', ('#' * 9))
        print(('-' * 43))
        table = PrettyTable(['Performance Metrics', 'Values'])
        stats1 = []
        stats1.append('Process Time (seconds)')
        stats1.append(processTime)
        table.add_row(stats1)
        stats2 = []
        stats2.append('Memory Usage (KB)')
        stats2.append(float((memoryUsage / 1024)))
        table.add_row(stats2)
        stats3 = []
        stats3.append('Time for consensus (seconds)')
        stats3.append(elapsedTime)
        table.add_row(stats3)
        print(table)
        print(('#' * 43))
        print('\n')

    def _Controller_handler_209(self):
        self.printMetrics()
    _Controller_handler_209._labels = None
    _Controller_handler_209._notlabels = None

class Main(da.NodeProcess):

    def __init__(self, procimpl, forwarder, **props):
        super().__init__(procimpl, forwarder, **props)
        self._Node_ReceivedEvent_0 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_0', PatternExpr_635, sources=[PatternExpr_639], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def run(self):
        """
        The main method which is used to spawn Proposer, Acceptor and Learner processes 
        for the Performance execution mode. 
        Arguments for the number of proposers, acceptors, learners and byzantine processes
        will be specified during runtime.
        """
        f = (int(sys.argv[1]) if (len(sys.argv) > 1) else 1)
        p = (int(sys.argv[2]) if (len(sys.argv) > 2) else 4)
        a = (int(sys.argv[3]) if (len(sys.argv) > 3) else 6)
        l = (int(sys.argv[4]) if (len(sys.argv) > 4) else 4)
        controller = self.new(Controller, (), num=1)
        leaderelect = self.new(fab.Election)
        proposers = self.new(fab.Proposer, num=p)
        acceptors = self.new(fab.Acceptor, num=a)
        learners = self.new(fab.Learner, num=l)
        mode = 3
        lt = 5
        self._setup(leaderelect, (list(proposers), acceptors, p, f, mode, controller))
        for proposer in proposers:
            self._setup(proposer, ((proposers - {proposer}), learners, acceptors, leaderelect, p, a, l, f, mode, None, controller))
        for acceptor in acceptors:
            self._setup(acceptor, (learners, (acceptors - {acceptor}), leaderelect, a, f, mode, None, controller))
        for learner in learners:
            self._setup(learner, (proposers, acceptors, (learners - {learner}), a, f, lt, mode, None, controller))
        self._start(controller)
        self._start(proposers)
        self._start(leaderelect)
        self._start(acceptors)
        self._start(learners)
        super()._label('_st_label_627', block=False)
        learner = None

        def UniversalOpExpr_628():
            nonlocal learner
            for learner in learners:
                if (not PatternExpr_641.match_iter(self._Node_ReceivedEvent_0, _BoundPattern647_=learner)):
                    return False
            return True
        _st_label_627 = 0
        while (_st_label_627 == 0):
            _st_label_627 += 1
            if UniversalOpExpr_628():
                _st_label_627 += 1
            else:
                super()._label('_st_label_627', block=True)
                _st_label_627 -= 1
        self.send('consensus', to=controller)
        self.send('done', to=((proposers | acceptors) | learners))
        self.send('done', to=leaderelect)
        self.send('done', to=controller)
