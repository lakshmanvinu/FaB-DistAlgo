# -*- generated by 1.1.0b13 -*-
import da
PatternExpr_514 = da.pat.TuplePattern([da.pat.ConstantPattern('suspect'), da.pat.BoundPattern('_BoundPattern517_')])
PatternExpr_520 = da.pat.FreePattern('proposer')
PatternExpr_562 = da.pat.TuplePattern([da.pat.ConstantPattern('suspect'), da.pat.FreePattern('pn')])
PatternExpr_569 = da.pat.FreePattern('proposer')
PatternExpr_585 = da.pat.ConstantPattern('done')
PatternExpr_589 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.ConstantPattern('done')])
PatternExpr_779 = da.pat.TuplePattern([da.pat.ConstantPattern('learned'), da.pat.BoundPattern('_BoundPattern782_'), da.pat.BoundPattern('_BoundPattern783_')])
PatternExpr_786 = da.pat.FreePattern('lrnd')
PatternExpr_823 = da.pat.TuplePattern([da.pat.ConstantPattern('learned'), da.pat.FreePattern('pnumber'), da.pat.FreePattern('value')])
PatternExpr_832 = da.pat.FreePattern('learner')
PatternExpr_845 = da.pat.TuplePattern([da.pat.ConstantPattern('satisfied'), da.pat.FreePattern('pnumber'), da.pat.FreePattern('value')])
PatternExpr_854 = da.pat.FreePattern('proposer')
PatternExpr_862 = da.pat.ConstantPattern('leaderdone')
PatternExpr_866 = da.pat.FreePattern('election')
PatternExpr_882 = da.pat.ConstantPattern('leaderdone')
PatternExpr_886 = da.pat.BoundPattern('_BoundPattern887_')
PatternExpr_901 = da.pat.TuplePattern([da.pat.ConstantPattern('satisfied'), da.pat.BoundPattern('_BoundPattern904_'), da.pat.BoundPattern('_BoundPattern905_')])
PatternExpr_908 = da.pat.FreePattern('prop')
PatternExpr_1095 = da.pat.TuplePattern([da.pat.ConstantPattern('propose'), da.pat.FreePattern('pnum'), da.pat.FreePattern('val'), da.pat.FreePattern('PC')])
PatternExpr_1106 = da.pat.FreePattern('l')
PatternExpr_1120 = da.pat.TuplePattern([da.pat.ConstantPattern('rep'), da.pat.FreePattern('val'), da.pat.FreePattern('pnum'), da.pat.FreePattern('commit_proof')])
PatternExpr_1131 = da.pat.FreePattern('acceptor')
PatternExpr_1154 = da.pat.TuplePattern([da.pat.ConstantPattern('leader'), da.pat.FreePattern('pnum'), da.pat.FreePattern('pr')])
PatternExpr_1163 = da.pat.FreePattern('election')
PatternExpr_1202 = da.pat.ConstantPattern('done')
PatternExpr_1234 = da.pat.TuplePattern([da.pat.ConstantPattern('learned'), da.pat.FreePattern(None), da.pat.FreePattern(None)])
PatternExpr_1241 = da.pat.FreePattern('lrn')
PatternExpr_1263 = da.pat.TuplePattern([da.pat.ConstantPattern('learned'), da.pat.BoundPattern('_BoundPattern1266_'), da.pat.BoundPattern('_BoundPattern1267_')])
PatternExpr_1270 = da.pat.FreePattern('lrn')
PatternExpr_1206 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.ConstantPattern('done')])
PatternExpr_888 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern894_')]), da.pat.ConstantPattern('leaderdone')])
PatternExpr_1518 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('v'), da.pat.FreePattern('pn')])
PatternExpr_1590 = da.pat.TuplePattern([da.pat.ConstantPattern('propose'), da.pat.FreePattern('pnumber'), da.pat.FreePattern('value'), da.pat.FreePattern('progcert')])
PatternExpr_1601 = da.pat.FreePattern('leader')
PatternExpr_1681 = da.pat.TuplePattern([da.pat.ConstantPattern('leader'), da.pat.FreePattern('reg'), da.pat.FreePattern('pr')])
PatternExpr_1697 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('value'), da.pat.FreePattern('pnumber')])
PatternExpr_1706 = da.pat.FreePattern('acceptor')
PatternExpr_1764 = da.pat.TuplePattern([da.pat.ConstantPattern('query'), da.pat.FreePattern('pnumber'), da.pat.FreePattern('pr')])
PatternExpr_1773 = da.pat.FreePattern('proposer')
PatternExpr_1789 = da.pat.ConstantPattern('done')
PatternExpr_1793 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.ConstantPattern('done')])
PatternExpr_1927 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.BoundPattern('_BoundPattern1930_'), da.pat.BoundPattern('_BoundPattern1931_')])
PatternExpr_1934 = da.pat.FreePattern('acc')
PatternExpr_2087 = da.pat.TuplePattern([da.pat.ConstantPattern('learnt'), da.pat.BoundPattern('_BoundPattern2090_'), da.pat.BoundPattern('_BoundPattern2091_')])
PatternExpr_2094 = da.pat.FreePattern('lrns')
PatternExpr_2121 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('value'), da.pat.FreePattern('pnumber')])
PatternExpr_2130 = da.pat.FreePattern('acceptor')
PatternExpr_2141 = da.pat.ConstantPattern('pull')
PatternExpr_2145 = da.pat.FreePattern('learner')
PatternExpr_2170 = da.pat.TuplePattern([da.pat.ConstantPattern('learnt'), da.pat.FreePattern('pnumber'), da.pat.FreePattern('value')])
PatternExpr_2179 = da.pat.FreePattern('learner')
PatternExpr_2189 = da.pat.TuplePattern([da.pat.ConstantPattern('commitproof'), da.pat.FreePattern('cp')])
PatternExpr_2196 = da.pat.FreePattern('acceptor')
PatternExpr_2229 = da.pat.ConstantPattern('done')
PatternExpr_2233 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.ConstantPattern('done')])
_config_object = {}
import math
from random import randint
import logging

def valid(cp, value, pnumber, acc, byz):
    '\n    Checks for commit proof from a quorum of aacceptors\n\n    :param cp: commit proof\n    :type cp: dict\n    :param value: value of proposed element\n    :type value: int\n    :param pnumber: proposal number\n    :type pnumber: int\n    :param acc: number of acceptors\n    :type acc: int\n    :param byz: number of byzantine faults\n    :type byz: int\n    :return: valid\n    :rtype: Bool\n    '
    l = list(cp.values()).count((value, pnumber))
    if (l >= math.ceil((((acc + byz) + 1) / 2))):
        return True
    return False

def vouches_for(progcert, value, pnumber, acc, byz):
    '\n    To check if a progress certificate vouches for a value and proposal number\n\n    :param progcert: progress certificate\n    :type progcert: dict\n    :param value: value proposed for an element\n    :type value: int\n    :param pnumber: proposal number\n    :type pnumber: int\n    :param acc: number of acceptors\n    :type acc: int\n    :param byz: number of byzantine faults\n    :type byz: int\n    :return: vouches for\n    :rtype: Bool\n    '
    valoccurdict = {}
    for (key, val) in progcert.items():
        if (not (val[0] == value)):
            if (val[0] in valoccurdict):
                valoccurdict[val[0]] += 1
            else:
                valoccurdict[val[0]] = 1
    m = 0
    if valoccurdict:
        m = max(valoccurdict.values())
    if (m >= math.ceil((((acc - byz) + 1) / 2))):
        return False
    count = 0
    for (v, pn, cp) in progcert.values():
        if ((not (v == value)) and valid(cp, v, pn, acc, byz)):
            return False
    return True

def get_logger_level(mode):
    '\n    Returns the logger level for output statements\n\n    :param mode: Mode of execution\n    :type mode: int\n    :return: loglevel\n    :rtype: Logging object\n    '
    if ((mode == 1) or (mode == 4)):
        loglevel = logging.INFO
    elif ((mode == 2) or (mode == 3)):
        loglevel = logging.DEBUG
    return loglevel

class Election(da.DistProcess):

    def __init__(self, procimpl, forwarder, **props):
        super().__init__(procimpl, forwarder, **props)
        self._ElectionReceivedEvent_0 = []
        self._ElectionReceivedEvent_2 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ElectionReceivedEvent_0', PatternExpr_514, sources=[PatternExpr_520], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ElectionReceivedEvent_1', PatternExpr_562, sources=[PatternExpr_569], destinations=None, timestamps=None, record_history=None, handlers=[self._Election_handler_561]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ElectionReceivedEvent_2', PatternExpr_585, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, proposers, acceptors, p, f, mode, controller, **rest_2242):
        super().setup(proposers=proposers, acceptors=acceptors, p=p, f=f, mode=mode, controller=controller, **rest_2242)
        self._state.proposers = proposers
        self._state.acceptors = acceptors
        self._state.p = p
        self._state.f = f
        self._state.mode = mode
        self._state.controller = controller
        '\n        Setup method for leader-election process.\n\n        :param proposers: List of proposers\n        :type proposers: list\n        :param acceptors: Set of acceptors\n        :type acceptors: set\n        :param p: Number of proposers\n        :type p: int\n        :param f: Number of byzantine faults\n        :type f: int\n        :param mode: Mode of execution\n        :type mode: int\n        :param controller: Controller process\n        :type controller: process\n        :return: None\n        :rtype: None\n        '
        self._state.r = (self._state.p - 1)
        self._state.leader = None
        self._state.proof = None
        self._state.loglevel = get_logger_level(self._state.mode)

    def run(self):
        '\n        Run method for the leader election. Starts by choosing a proposer as leader and \n        informs other proposer about the leader election.\n        '
        self.leaderElection()
        super()._label('_st_label_582', block=False)
        _st_label_582 = 0
        while (_st_label_582 == 0):
            _st_label_582 += 1
            if PatternExpr_589.match_iter(self._ElectionReceivedEvent_2, SELF_ID=self._id):
                _st_label_582 += 1
            else:
                super()._label('_st_label_582', block=True)
                _st_label_582 -= 1
        self.sendmessage('leaderdone', self._state.leader)

    def sendmessage(self, msg, recepient):
        '\n        Wrapper method for the send method in distalgo\n\n        :param msg: message to be sent\n        :type msg: tuple\n        :param recepient: Recepient of the message\n        :type recepient: set\n        '
        if (self._state.mode == 2):
            self.send(msg, to=recepient)
            if (msg[0] == 'leader'):
                self.send(msg, to=self._state.controller)
        else:
            self.send(msg, to=recepient)

    def getRegency(self):
        '\n        Method to return number of current regent. If no correct node suspects it, \n        regency continues.\n\n        :return: Regency number\n        :rtype: int\n        '
        return self._state.r

    def getLeader(self):
        '\n        Method to return current leader.\n\n        :return: proposer\n        :rtype: process\n        '
        return self._state.proposers[(self._state.r % self._state.p)]

    def leaderElection(self):
        '\n        Method to perform leader election.\n\n        :return: None\n        :rtype: None\n        '
        self._state.r += 1
        self._state.leader = self.getLeader()
        pr = ''
        for j in range(3):
            pr += str(randint(1, 10))
        if (not (pr == '')):
            self._state.proof = pr
        self.output('NEW LEADER:', self._state.leader, '( Regency:', self._state.r, '| Proof:', self._state.proof, ')', level=self._state.loglevel)
        self.sendmessage(('leader', self._state.r, self._state.proof), ({self._state.leader} | self._state.acceptors))

    def onSuspect(self):
        '\n        This method is called when a proposer suspects the leader. If a quorum of nodes suspect\n        the leader, a new regency is begun and a new leader is elected.\n        '
        if (len({proposer for (_, (_, _, proposer), (_ConstantPattern531_, _BoundPattern533_)) in self._ElectionReceivedEvent_0 if (_ConstantPattern531_ == 'suspect') if (_BoundPattern533_ == self._state.r)}) >= math.ceil((((self._state.p + self._state.f) + 1) / 2))):
            self.sendmessage('leaderdone', self._state.leader)
            self.output('Leader', self._state.leader, 'suspected!', level=self._state.loglevel)
            self.leaderElection()

    def _Election_handler_561(self, pn, proposer):
        self.onSuspect()
    _Election_handler_561._labels = None
    _Election_handler_561._notlabels = None

class Proposer(da.DistProcess):

    def __init__(self, procimpl, forwarder, **props):
        super().__init__(procimpl, forwarder, **props)
        self._ProposerReceivedEvent_0 = []
        self._ProposerReceivedEvent_4 = []
        self._ProposerReceivedEvent_5 = []
        self._ProposerReceivedEvent_9 = []
        self._ProposerReceivedEvent_10 = []
        self._ProposerReceivedEvent_11 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_0', PatternExpr_779, sources=[PatternExpr_786], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_1', PatternExpr_823, sources=[PatternExpr_832], destinations=None, timestamps=None, record_history=None, handlers=[self._Proposer_handler_822]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_2', PatternExpr_845, sources=[PatternExpr_854], destinations=None, timestamps=None, record_history=None, handlers=[self._Proposer_handler_844]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_3', PatternExpr_862, sources=[PatternExpr_866], destinations=None, timestamps=None, record_history=None, handlers=[self._Proposer_handler_861]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_4', PatternExpr_882, sources=[PatternExpr_886], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_5', PatternExpr_901, sources=[PatternExpr_908], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_6', PatternExpr_1095, sources=[PatternExpr_1106], destinations=None, timestamps=None, record_history=None, handlers=[self._Proposer_handler_1094]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_7', PatternExpr_1120, sources=[PatternExpr_1131], destinations=None, timestamps=None, record_history=None, handlers=[self._Proposer_handler_1119]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_8', PatternExpr_1154, sources=[PatternExpr_1163], destinations=None, timestamps=None, record_history=None, handlers=[self._Proposer_handler_1153]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_9', PatternExpr_1202, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_10', PatternExpr_1234, sources=[PatternExpr_1241], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_ProposerReceivedEvent_11', PatternExpr_1263, sources=[PatternExpr_1270], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, proposers, learners, acceptors, election, p, a, l, f, mode, config, controller, **rest_2242):
        super().setup(proposers=proposers, learners=learners, acceptors=acceptors, election=election, p=p, a=a, l=l, f=f, mode=mode, config=config, controller=controller, **rest_2242)
        self._state.proposers = proposers
        self._state.learners = learners
        self._state.acceptors = acceptors
        self._state.election = election
        self._state.p = p
        self._state.a = a
        self._state.l = l
        self._state.f = f
        self._state.mode = mode
        self._state.config = config
        self._state.controller = controller
        '\n        Setup method for proposer process.\n        \n        :param proposers: set of proposers\n        :type proposers: set\n        :param learners: Set of learners.\n        :type learners: set\n        :param acceptors: Set of acceptors.\n        :type acceptors: set\n        :param election: Leader election process.\n        :type election: process\n        :param p: Number of proposers\n        :type p: int\n        :param a: Number of acceptors\n        :type a: int\n        :param l: Number of learners\n        :type l: int\n        :param f: Number of byzantine faults\n        :type f: int\n        :param mode: Mode of execution\n        :type mode: int\n        :param config: Config for byzantine replication\n        :type config: dict\n        :param controller: Controller process\n        :type controller: process\n        '
        self._state.PC = dict()
        self._state.isLeader = False
        self._state.pnumber = None
        self._state.proof = None
        self._state.value = None
        self._state.config = self._state.config
        self._state.byzproposal = 3
        self._state.loglevel = get_logger_level(self._state.mode)

    def run(self):
        '\n        Run method for the proposer. Waits for the timeout before checking if \n        Learned >= ceil((l+f+1)/2). If this is false, proposer "suspects" the leader.\n        '
        if (self._state.mode == 4):
            self._state.byzproposal = self._state.config['proposer_config']['byzpropconf'][self._id]
        while (not PatternExpr_1206.match_iter(self._ProposerReceivedEvent_9, SELF_ID=self._id)):
            super()._label('_st_label_1215', block=False)
            _st_label_1215 = 0
            while (_st_label_1215 == 0):
                _st_label_1215 += 1
                if False:
                    _st_label_1215 += 1
                elif self._timer_expired:
                    _st_label_1215 += 1
                else:
                    super()._label('_st_label_1215', block=True, timeout=12)
                    _st_label_1215 -= 1
            else:
                if (_st_label_1215 != 2):
                    continue
            self._timer_start()
            if (_st_label_1215 != 2):
                break
            if (not self._state.isLeader):
                if ((self._state.pnumber == None) and (self._state.value == None)):
                    self._state.l = len({lrn for (_, (_, _, lrn), (_ConstantPattern1252_, _, _)) in self._ProposerReceivedEvent_10 if (_ConstantPattern1252_ == 'learned')})
                else:
                    self._state.l = len({lrn for (_, (_, _, lrn), (_ConstantPattern1281_, _BoundPattern1283_, _BoundPattern1284_)) in self._ProposerReceivedEvent_11 if (_ConstantPattern1281_ == 'learned') if (_BoundPattern1283_ == self._state.pnumber) if (_BoundPattern1284_ == self._state.value)})
                if (self._state.l < math.ceil((((self._state.l + self._state.f) + 1) / 2))):
                    self.output('Suspecting leader!', self._state.pnumber, level=self._state.loglevel)
                    self.sendmessage(('suspect', self._state.pnumber), self._state.election)

    def sendmessage(self, msg, recepient):
        '\n        Wrapper method for the send method in distalgo\n\n        :param msg: message to be sent\n        :type msg: tuple\n        :param recepient: Recepient of the message\n        :type recepient: set\n        '
        if (self._state.mode == 1):
            self.send(msg, to=recepient)
        elif (self._state.mode == 2):
            self.send(msg, to=recepient)
            if (msg[0] == 'propose'):
                self.send(msg, to=self._state.controller)
        elif (self._state.mode == 3):
            self.send(msg, to=recepient)
        elif (self._state.mode == 4):
            if (self._state.isLeader and (msg[0] == 'propose') and (self._state.byzproposal < 2)):
                acc = self._state.config['leader_config']['propose_to'][self._state.byzproposal]
                self.send(msg, to=(acc | self._state.proposers))
                self._state.byzproposal += 1
                self._state.value += 1
            else:
                self.send(msg, to=recepient)

    def onLearned(self):
        "\n        Receive method for the 'learned' message that is sent by learners to proposers.\n        Appends learner to the set Learned and sends 'satisfied' to all proposers if \n        Learned >= ceil((l+f+1)/2).\n        \n        :return: None\n        :rtype: None\n        "
        if (len({lrnd for (_, (_, _, lrnd), (_ConstantPattern797_, _BoundPattern799_, _BoundPattern800_)) in self._ProposerReceivedEvent_0 if (_ConstantPattern797_ == 'learned') if (_BoundPattern799_ == self._state.pnumber) if (_BoundPattern800_ == self._state.value)}) >= math.ceil((((self._state.l + self._state.f) + 1) / 2))):
            self.sendmessage(('satisfied', self._state.pnumber, self._state.value), self._state.proposers)

    def onSatisfied(self):
        "\n        Receive method for the 'satisfied' message that is sent by a proposer to all other \n        proposers. Appends proposer to the set Satisfied. \n        \n        :return: None\n        :rtype: None\n        "
        pass

    def leaderOnStart(self):
        '\n        This method is used to send PROPOSE messages to all acceptors until \n        Satisfied >= ceil((p+f+1)/2).\n        '
        if self._state.isLeader:
            while (not PatternExpr_888.match_iter(self._ProposerReceivedEvent_4, _BoundPattern894_=self._state.election, SELF_ID=self._id)):
                self._state.l = len({prop for (_, (_, _, prop), (_ConstantPattern919_, _BoundPattern921_, _BoundPattern922_)) in self._ProposerReceivedEvent_5 if (_ConstantPattern919_ == 'satisfied') if (_BoundPattern921_ == self._state.pnumber) if (_BoundPattern922_ == self._state.value)})
                if (self._state.l < math.ceil((((self._state.p + self._state.f) + 1) / 2))):
                    self.output('PROPOSE: ( Pnumber:', self._state.pnumber, ' | Value:', self._state.value, ')', level=self._state.loglevel)
                    self.sendmessage(('propose', self._state.pnumber, self._state.value, self._state.PC), (self._state.acceptors | self._state.proposers))
                super()._label('_st_label_958', block=False)
                _st_label_958 = 0
                while (_st_label_958 == 0):
                    _st_label_958 += 1
                    if False:
                        _st_label_958 += 1
                    elif self._timer_expired:
                        _st_label_958 += 1
                    else:
                        super()._label('_st_label_958', block=True, timeout=3)
                        _st_label_958 -= 1
                else:
                    if (_st_label_958 != 2):
                        continue
                self._timer_start()
                if (_st_label_958 != 2):
                    break

    def leaderOnElected(self, newnumber, pr):
        "\n        This method is executed after a leader has been chosen. Sends QUERY to all acceptors\n        and waits for REP from a-f acceptors with a value, proposal number pnumber and \n        commit_proof. it checks vouches-for for a value v' such that value = v' before starting\n        the leader can start proposing values to acceptors.\n        \n        :param newnumber: new regency number\n        :type newnumber: int\n        :param pr: contains proof of a new leader\n        :type pr: tuple\n        :return: None\n        :rtype: None\n        "
        self._state.pnumber = newnumber
        self._state.proof = pr
        self.output('QUERY:', '( Pnumber:', self._state.pnumber, ' | Proof:', self._state.proof, ')', level=self._state.loglevel)
        self.sendmessage(('query', self._state.pnumber, self._state.proof), self._state.acceptors)
        super()._label('_st_label_991', block=False)
        _st_label_991 = 0
        while (_st_label_991 == 0):
            _st_label_991 += 1
            if (len(self._state.PC) >= (self._state.a - self._state.f)):
                vals = {v for (v, _, _) in self._state.PC.values() if (not (v == None))}
                if (len(vals) > 0):
                    for v in vals:
                        if vouches_for(self._state.PC, v, self._state.pnumber, self._state.a, self._state.f):
                            self._state.value = v
                            break
                else:
                    self._state.value = randint(1, 100)
                if (not (self._state.value == None)):
                    self.leaderOnStart()
                else:
                    print('\n')
                    print(('-' * 95))
                    print(('#' * 36), ' LIVENESS VIOLATION! ', ('#' * 36))
                    print(('-' * 95))
                    print('\n')
                _st_label_991 += 1
            elif self._timer_expired:
                self.output('TIMEOUT: No response from Acceptors!', level=logging.ERROR)
                _st_label_991 += 1
            else:
                super()._label('_st_label_991', block=True, timeout=5)
                _st_label_991 -= 1
        self._timer_start()

    def _Proposer_handler_822(self, pnumber, value, learner):
        self.onLearned()
    _Proposer_handler_822._labels = None
    _Proposer_handler_822._notlabels = None

    def _Proposer_handler_844(self, pnumber, value, proposer):
        self.onSatisfied()
    _Proposer_handler_844._labels = None
    _Proposer_handler_844._notlabels = None

    def _Proposer_handler_861(self, election):
        self._state.isLeader = False
    _Proposer_handler_861._labels = None
    _Proposer_handler_861._notlabels = None

    def _Proposer_handler_1094(self, pnum, val, PC, l):
        if (not self._state.isLeader):
            self._state.pnumber = pnum
            self._state.value = val
    _Proposer_handler_1094._labels = None
    _Proposer_handler_1094._notlabels = None

    def _Proposer_handler_1119(self, val, pnum, commit_proof, acceptor):
        self.output('REP from', acceptor, '( Value:', val, '| Pnumber', pnum, ')', level=self._state.loglevel)
        self._state.PC[acceptor] = (val, pnum, commit_proof)
    _Proposer_handler_1119._labels = None
    _Proposer_handler_1119._notlabels = None

    def _Proposer_handler_1153(self, pnum, pr, election):
        self._state.isLeader = True
        self._state.value = None
        self._state.PC = dict()
        self.leaderOnElected(pnum, pr)
    _Proposer_handler_1153._labels = None
    _Proposer_handler_1153._notlabels = None

class Acceptor(da.DistProcess):

    def __init__(self, procimpl, forwarder, **props):
        super().__init__(procimpl, forwarder, **props)
        self._AcceptorReceivedEvent_0 = []
        self._AcceptorReceivedEvent_5 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_0', PatternExpr_1518, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_1', PatternExpr_1590, sources=[PatternExpr_1601], destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_handler_1589]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_2', PatternExpr_1681, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_handler_1680]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_3', PatternExpr_1697, sources=[PatternExpr_1706], destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_handler_1696]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_4', PatternExpr_1764, sources=[PatternExpr_1773], destinations=None, timestamps=None, record_history=None, handlers=[self._Acceptor_handler_1763]), da.pat.EventPattern(da.pat.ReceivedEvent, '_AcceptorReceivedEvent_5', PatternExpr_1789, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, learners, acceptors, election, a, f, mode, config, controller, **rest_2242):
        super().setup(learners=learners, acceptors=acceptors, election=election, a=a, f=f, mode=mode, config=config, controller=controller, **rest_2242)
        self._state.learners = learners
        self._state.acceptors = acceptors
        self._state.election = election
        self._state.a = a
        self._state.f = f
        self._state.mode = mode
        self._state.config = config
        self._state.controller = controller
        '\n        Setup method for Acceptor process.\n        \n        :param learners: Set of learners.\n        :type learners: set\n        :param acceptors: Set of acceptors.\n        :type acceptors: set\n        :param election: Leader election process.\n        :type election: process\n        :param a: Number of acceptors\n        :type a: int\n        :param f: Number of byzantine faults\n        :type f: int\n        :param mode: Mode of execution\n        :type mode: int\n        :param config: Config for byzantine replication\n        :type config: dict\n        :param controller: Controller process\n        :type controller: process\n        '
        self._state.tentative_commit_proof = dict()
        self._state.commit_proof = dict()
        self._state.accepted = None
        self._state.leader = None
        self._state.regency = None
        self._state.proof = None
        self._state.config = self._state.config
        self._state.resptoacc = 0
        self._state.resptorep = 0
        self._state.loglevel = get_logger_level(self._state.mode)

    def run(self):
        '\n        Method to run the process.\n        '
        super()._label('_st_label_1786', block=False)
        _st_label_1786 = 0
        while (_st_label_1786 == 0):
            _st_label_1786 += 1
            if PatternExpr_1793.match_iter(self._AcceptorReceivedEvent_5, SELF_ID=self._id):
                _st_label_1786 += 1
            else:
                super()._label('_st_label_1786', block=True)
                _st_label_1786 -= 1

    def sendmessage(self, msg, recepient):
        '\n        Wrapper method for the send method in distalgo\n\n        :param msg: message to be sent\n        :type msg: tuple\n        :param recepient: Recepient of the message\n        :type recepient: set\n        '
        if (self._state.mode == 2):
            self.send(msg, to=recepient)
            if (msg[0] == 'accepted'):
                self.send(msg, to=self._state.controller)
        elif (self._state.mode == 4):
            if ((msg[0] == 'accepted') and (self._state.resptoacc < 2)):
                acc = set(self._state.config['acceptor_config']['accept_to'][self._state.resptoacc][self._id])
                self.send(msg, to=acc)
                self._state.resptoacc += 1
            elif (msg[0] == 'rep'):
                if (self._state.resptorep == 1):
                    if (self._id in self._state.config['acceptor_config']['rep_from']):
                        self.send(msg, to=recepient)
                else:
                    self.send(msg, to=recepient)
                self._state.resptorep += 1
            else:
                self.send(msg, to=recepient)
        else:
            self.send(msg, to=recepient)

    def onPropose(self, leader, value, pnumber, progcert):
        '\n        Receive Proposal from a leader\n        * If the value is proposed by the elected leader, only then the acceptor listens to the proposer, else discard the message\n        * If a new value is proposed by the leader, then change the progress certificate.\n        * Else, accept the value sent by the leader and send accepted message to all the learners and acceptors about the learned value.\n        \n        :param leader: The leader process\n        :type leader: Process\n        :param value: The value accepted\n        :type value: int\n        :param pnumber: The proposal number of the accepted value\n        :type pnumber: int\n        :param progcert: The progress certificate is a list of valid (proposal numbers, accepted values)\n        :type progcert: List<tuples>\n        '
        if (not (pnumber == self._state.regency)):
            return
        pn = v = None

        def ExistentialOpExpr_1516():
            nonlocal pn, v
            for (_, _, (_ConstantPattern1535_, v, pn)) in self._AcceptorReceivedEvent_0:
                if (_ConstantPattern1535_ == 'accepted'):
                    if ((pnumber <= pn) or ((not (v == value)) and (not vouches_for(progcert, value, pnumber, self._state.a, self._state.f)))):
                        return True
            return False
        if ExistentialOpExpr_1516():
            return
        self._state.accepted = (value, pnumber)
        self._state.tentative_commit_proof[self._id] = (value, pnumber)
        self.output('ACCEPT: ( Pnumber:', pnumber, ' | Value:', value, ')', level=self._state.loglevel)
        self.sendmessage(('accepted', value, pnumber), (self._state.learners | self._state.acceptors))

    def onAccepted(self, value, pnumber, acceptor):
        '\n        Receive Accepted proposal number and value\n        Update the tentative commit proof of the corresponding acceptor, \n        check for its validity and send the commit proof to all the learners.\n        \n        :param value: The value accepted\n        :type value: int\n        :param pnumber: The proposal number of the accepted value\n        :type pnumber: int\n        :param acceptor: The acceptor who sent the accepted message\n        :type acceptor: process\n        :return: None\n        '
        if ((self._state.tentative_commit_proof == None) or (not (acceptor in self._state.tentative_commit_proof))):
            self._state.tentative_commit_proof[acceptor] = (value, pnumber)
        elif (self._state.tentative_commit_proof[acceptor][1] < pnumber):
            self._state.tentative_commit_proof[acceptor] = (value, pnumber)
        if valid(self._state.tentative_commit_proof, value, self._state.regency, self._state.a, self._state.f):
            self._state.commit_proof = self._state.tentative_commit_proof
            self.sendmessage(('commitproof', self._state.commit_proof), self._state.learners)

    def onNewLeader(self, reg, pr):
        '\n        Method to store regency and proof, on election of a new leader, \n        \n        :param reg: The latest regency number\n        :type reg: int\n        :param pr: The proof value for new leader\n        :type pr: int\n        :return: None\n        '
        self._state.regency = reg
        self._state.proof = pr

    def onQuery(self, proposer, pnumber, pr):
        '\n        Receive onQuery from Proposer\n        Get the regency number of the proposer and check if that proposer is the leader. If not, return bad request. \n        Else, get the elected leader and send a reply of accepted value to the leader.\n        \n        :param proposer: The proposer process sending the proposal\n        :type proposer: Process\n        :param pnumber: The proposal number of the accepted value\n        :type pnumber: int\n        :param pr: The proof value\n        :type pr: int\n        :return: None\n        '
        if (pr == self._state.proof):
            if (not (pnumber == self._state.regency)):
                return
            self._state.leader = proposer
            if (not (self._state.accepted == None)):
                self.sendmessage(('rep', self._state.accepted[0], self._state.accepted[1], self._state.commit_proof), self._state.leader)
            else:
                self.sendmessage(('rep', self._state.accepted, pnumber, self._state.commit_proof), self._state.leader)

    def _Acceptor_handler_1589(self, pnumber, value, progcert, leader):
        self.onPropose(leader, value, pnumber, progcert)
    _Acceptor_handler_1589._labels = None
    _Acceptor_handler_1589._notlabels = None

    def _Acceptor_handler_1680(self, reg, pr):
        self.onNewLeader(reg, pr)
    _Acceptor_handler_1680._labels = None
    _Acceptor_handler_1680._notlabels = None

    def _Acceptor_handler_1696(self, value, pnumber, acceptor):
        self.onAccepted(value, pnumber, acceptor)
    _Acceptor_handler_1696._labels = None
    _Acceptor_handler_1696._notlabels = None

    def _Acceptor_handler_1763(self, pnumber, pr, proposer):
        self.onQuery(proposer, pnumber, pr)
    _Acceptor_handler_1763._labels = None
    _Acceptor_handler_1763._notlabels = None

class Learner(da.DistProcess):

    def __init__(self, procimpl, forwarder, **props):
        super().__init__(procimpl, forwarder, **props)
        self._LearnerReceivedEvent_0 = []
        self._LearnerReceivedEvent_1 = []
        self._LearnerReceivedEvent_6 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_LearnerReceivedEvent_0', PatternExpr_1927, sources=[PatternExpr_1934], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_LearnerReceivedEvent_1', PatternExpr_2087, sources=[PatternExpr_2094], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_LearnerReceivedEvent_2', PatternExpr_2121, sources=[PatternExpr_2130], destinations=None, timestamps=None, record_history=None, handlers=[self._Learner_handler_2120]), da.pat.EventPattern(da.pat.ReceivedEvent, '_LearnerReceivedEvent_3', PatternExpr_2141, sources=[PatternExpr_2145], destinations=None, timestamps=None, record_history=None, handlers=[self._Learner_handler_2140]), da.pat.EventPattern(da.pat.ReceivedEvent, '_LearnerReceivedEvent_4', PatternExpr_2170, sources=[PatternExpr_2179], destinations=None, timestamps=None, record_history=None, handlers=[self._Learner_handler_2169]), da.pat.EventPattern(da.pat.ReceivedEvent, '_LearnerReceivedEvent_5', PatternExpr_2189, sources=[PatternExpr_2196], destinations=None, timestamps=None, record_history=None, handlers=[self._Learner_handler_2188]), da.pat.EventPattern(da.pat.ReceivedEvent, '_LearnerReceivedEvent_6', PatternExpr_2229, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, proposers, acceptors, learners, a, f, lt, mode, config, controller, **rest_2242):
        super().setup(proposers=proposers, acceptors=acceptors, learners=learners, a=a, f=f, lt=lt, mode=mode, config=config, controller=controller, **rest_2242)
        self._state.proposers = proposers
        self._state.acceptors = acceptors
        self._state.learners = learners
        self._state.a = a
        self._state.f = f
        self._state.lt = lt
        self._state.mode = mode
        self._state.config = config
        self._state.controller = controller
        '\n        Setup method for learner process.\n\n        :param proposers: Set of proposers.\n        :type proposers: set\n        :param acceptors: Set of acceptors.\n        :type acceptors: set\n        :param learners: Set of learners.\n        :type learners: set\n        :param a: Number of acceptors\n        :type a: int\n        :param f: Number of byzantine faults\n        :type f: int\n        :param mode: Mode of execution\n        :type mode: int\n        :param config: Config for byzantine replication\n        :type config: dict\n        :param controller: Controller process\n        :type controller: process\n        '
        self._state.learned = None
        self._state.accepted = dict()
        self._state.commproof = dict()
        self._state.loglevel = get_logger_level(self._state.mode)

    def run(self):
        '\n        Method to run the process. \n        Starts by sending a pull request to all learners to check if a value has been learned already\n        '
        super()._label('_st_label_2208', block=False)
        _st_label_2208 = 0
        while (_st_label_2208 == 0):
            _st_label_2208 += 1
            if False:
                _st_label_2208 += 1
            elif self._timer_expired:
                _st_label_2208 += 1
            else:
                super()._label('_st_label_2208', block=True, timeout=self._state.lt)
                _st_label_2208 -= 1
        self._timer_start()
        if (not (self._state.learned == None)):
            self.sendmessage('done', self.parent())
        else:
            self.output('Not learned anything!', level=self._state.loglevel)
        super()._label('_st_label_2226', block=False)
        _st_label_2226 = 0
        while (_st_label_2226 == 0):
            _st_label_2226 += 1
            if PatternExpr_2233.match_iter(self._LearnerReceivedEvent_6, SELF_ID=self._id):
                _st_label_2226 += 1
            else:
                super()._label('_st_label_2226', block=True)
                _st_label_2226 -= 1

    def sendmessage(self, msg, recepient):
        '\n        Wrapper method for the send method in distalgo\n\n        :param msg: message to be sent\n        :type msg: tuple\n        :param recepient: Recepient of the message\n        :type recepient: set\n        '
        if (self._state.mode == 1):
            self.send(msg, to=recepient)
        if (self._state.mode == 2):
            self.send(msg, to=recepient)
            if (msg[0] == 'learned'):
                self.send(msg, to=self._state.controller)
        elif (self._state.mode == 3):
            self.send(msg, to=recepient)
        elif (self._state.mode == 4):
            pass

    def onAccepted(self, acceptor, pnumber, value):
        '\n        Receive method to receive accepted messages from acceptors\n        When an acceptor accepts a value proposed by a proposal number, it sends it to the learner\n        to learn the value.\n        The learner learns the value when the same value is being sent by (a+3f+1)/2 acceptors.\n        \n        :param pnumber: Proposal nunber of the accepted value\n        :type pnumber: int \n        :param value: Accepted value\n        :type value: int\n        :return: None\n        '
        self._state.accepted[acceptor] = (pnumber, value)
        if (len({acc for (_, (_, _, acc), (_ConstantPattern1945_, _BoundPattern1947_, _BoundPattern1948_)) in self._LearnerReceivedEvent_0 if (_ConstantPattern1945_ == 'accepted') if (_BoundPattern1947_ == pnumber) if (_BoundPattern1948_ == value)}) > math.ceil((((self._state.a + (3 * self._state.f)) + 1) / 2))):
            self.learn(pnumber, value)

    def onCommitProof(self, cp, acceptor):
        '\n        Receive method to receive commit-proof messages from acceptors\n        If the learner receives the commit-proof message with the same proposal number and value \n        from (a+f+1)/2 acceptors then learn the value.\n\n        :param cp: Commit-proof received from an acceptor\n        :type value: int\n        :return: None\n        '
        super()._label('_st_label_1974', block=False)
        _st_label_1974 = 0
        while (_st_label_1974 == 0):
            _st_label_1974 += 1
            if (acceptor in self._state.accepted):
                (pn, val) = self._state.accepted[acceptor]
                self._state.commproof[acceptor] = cp
                count = 0
                for acc in self._state.commproof.keys():
                    if valid(self._state.commproof[acc], val, pn, self._state.a, self._state.f):
                        count += 1
                if (count >= math.ceil((((self._state.a + self._state.f) + 1) / 2))):
                    if (not self._state.learned):
                        self.output('COMMITPROOF: ( Pnumber:', pn, ' | Value:', val, ')', level=self._state.loglevel)
                        self.learn(pn, val)
                _st_label_1974 += 1
            elif self._timer_expired:
                pass
                _st_label_1974 += 1
            else:
                super()._label('_st_label_1974', block=True, timeout=2)
                _st_label_1974 -= 1
        self._timer_start()

    def learn(self, pnumber, value):
        '\n        The learn method is executed after majority of the learners learn a value.\n        If there are more than f+1 learners returning the same value,\n        this method sends a message to the proposers with the learned value.\n\n        :param pnumber: Proposal nunber of the accepted value\n        :type pnumber: int \n        :param value: Accepted value\n        :type value: int\n        :return: None\n        '
        self._state.learned = (pnumber, value)
        self.output('LEARNED: ( Pnumber:', pnumber, ' | Value:', value, ')', level=self._state.loglevel)
        self.sendmessage(('learned', pnumber, value), self._state.proposers)

    def onLearned(self, pnumber, value):
        '\n        This method is executed when a learner has learnt a value\n\n        :param pnumber: Proposal nunber of the accepted value\n        :type pnumber: int \n        :param value: Accepted value\n        :type value: int\n        :return: None\n        '
        if (len({lrns for (_, (_, _, lrns), (_ConstantPattern2105_, _BoundPattern2107_, _BoundPattern2108_)) in self._LearnerReceivedEvent_1 if (_ConstantPattern2105_ == 'learnt') if (_BoundPattern2107_ == pnumber) if (_BoundPattern2108_ == value)}) > (self._state.f + 1)):
            self.learn(pnumber, value)

    def _Learner_handler_2120(self, value, pnumber, acceptor):
        self.onAccepted(acceptor, pnumber, value)
    _Learner_handler_2120._labels = None
    _Learner_handler_2120._notlabels = None

    def _Learner_handler_2140(self, learner):
        if (not (self._state.learned == None)):
            (pn, val) = self._state.learned
            self.sendmessage(('learnt', pn, val), learner)
    _Learner_handler_2140._labels = None
    _Learner_handler_2140._notlabels = None

    def _Learner_handler_2169(self, pnumber, value, learner):
        self.onLearned(pnumber, value)
    _Learner_handler_2169._labels = None
    _Learner_handler_2169._notlabels = None

    def _Learner_handler_2188(self, cp, acceptor):
        self.onCommitProof(cp, acceptor)
    _Learner_handler_2188._labels = None
    _Learner_handler_2188._notlabels = None
