# -*- generated by 1.1.0b13 -*-
import da
PatternExpr_272 = da.pat.TuplePattern([da.pat.ConstantPattern('learned'), da.pat.BoundPattern('_BoundPattern275_'), da.pat.BoundPattern('_BoundPattern276_')])
PatternExpr_279 = da.pat.FreePattern('lrn')
PatternExpr_332 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.BoundPattern('_BoundPattern335_'), da.pat.BoundPattern('_BoundPattern336_')])
PatternExpr_339 = da.pat.FreePattern('acc')
PatternExpr_395 = da.pat.TuplePattern([da.pat.ConstantPattern('learned'), da.pat.BoundPattern('_BoundPattern398_'), da.pat.BoundPattern('_BoundPattern399_')])
PatternExpr_402 = da.pat.FreePattern('lrn')
PatternExpr_435 = da.pat.TuplePattern([da.pat.ConstantPattern('propose'), da.pat.FreePattern('pnumber'), da.pat.FreePattern('value'), da.pat.FreePattern('PC')])
PatternExpr_453 = da.pat.TuplePattern([da.pat.ConstantPattern('accepted'), da.pat.FreePattern('value'), da.pat.FreePattern('pnumber')])
PatternExpr_471 = da.pat.TuplePattern([da.pat.ConstantPattern('leader'), da.pat.FreePattern('r'), da.pat.FreePattern(None)])
PatternExpr_679 = da.pat.ConstantPattern('done')
PatternExpr_683 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)]), da.pat.ConstantPattern('done')])
PatternExpr_915 = da.pat.ConstantPattern('done')
PatternExpr_919 = da.pat.BoundPattern('_BoundPattern920_')
PatternExpr_950 = da.pat.ConstantPattern('done')
PatternExpr_954 = da.pat.BoundPattern('_BoundPattern955_')
PatternExpr_921 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern927_')]), da.pat.ConstantPattern('done')])
PatternExpr_956 = da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.TuplePattern([da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.BoundPattern('_BoundPattern962_')]), da.pat.ConstantPattern('done')])
_config_object = {}
import math
import sys
# import fab
import logging
from prettytable import PrettyTable

class CorrectnessLiveness(da.DistProcess):
    """
    This is the Correctness process for the Fast Byzantine Consensus to verify the correctness of the implementation
    """
    def __init__(self, procimpl, forwarder, **props):
        super().__init__(procimpl, forwarder, **props)
        self._CorrectnessLivenessReceivedEvent_0 = []
        self._CorrectnessLivenessReceivedEvent_1 = []
        self._CorrectnessLivenessReceivedEvent_2 = []
        self._CorrectnessLivenessReceivedEvent_6 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_CorrectnessLivenessReceivedEvent_0', PatternExpr_272, sources=[PatternExpr_279], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_CorrectnessLivenessReceivedEvent_1', PatternExpr_332, sources=[PatternExpr_339], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_CorrectnessLivenessReceivedEvent_2', PatternExpr_395, sources=[PatternExpr_402], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_CorrectnessLivenessReceivedEvent_3', PatternExpr_435, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._CorrectnessLiveness_handler_434]), da.pat.EventPattern(da.pat.ReceivedEvent, '_CorrectnessLivenessReceivedEvent_4', PatternExpr_453, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._CorrectnessLiveness_handler_452]), da.pat.EventPattern(da.pat.ReceivedEvent, '_CorrectnessLivenessReceivedEvent_5', PatternExpr_471, sources=None, destinations=None, timestamps=None, record_history=None, handlers=[self._CorrectnessLiveness_handler_470]), da.pat.EventPattern(da.pat.ReceivedEvent, '_CorrectnessLivenessReceivedEvent_6', PatternExpr_679, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, l, f, a):
        """
        Setup method for Correctness verification process.

        :param l: Number of learners
        :type l: int
        :param f: Number of byzantine faults
        :type f: int
        :param a: Number of acceptors
        :type a: int
        """
        super().setup(l=l, f=f, a=a, **rest_965)
        self._state.l = l
        self._state.f = f
        self._state.a = a
        self._state.proposed = set()
        self._state.accepted = set()
        self._state.terminate = False

    def run(self):
        super()._label('_st_label_676', block=False)
        _st_label_676 = 0
        while (_st_label_676 == 0):
            _st_label_676 += 1
            if PatternExpr_683.match_iter(self._CorrectnessLivenessReceivedEvent_6, SELF_ID=self._id):
                _st_label_676 += 1
            else:
                super()._label('_st_label_676', block=True)
                _st_label_676 -= 1
        self.checkCorrectness()
        super()._label('_st_label_696', block=False)
        _st_label_696 = 0
        while (_st_label_696 == 0):
            _st_label_696 += 1
            if (self._state.terminate == True):
                _st_label_696 += 1
            else:
                super()._label('_st_label_696', block=True)
                _st_label_696 -= 1
        self.send('done', to=self.parent())

    def rule_cs1(self):
        '''
        Only a value that has been proposed must be chosen
        '''
        value = None

        def UniversalOpExpr_218():
            nonlocal value
            for (value, _) in self._state.accepted:
                if (not (value in self._state.proposed)):
                    return False
            return True
        if UniversalOpExpr_218():
            return True
        return False

    def rule_cs2(self):
        '''
        Only a single value may be chosen. 
        For every proposal number atmost one value is chosen.
        '''
        if (not (len(self._state.accepted) == 1)):
            return False
        return True

    def rule_cs3(self):
        '''
        Only Chosen value may be learned by a correct learner.
        Some value is eventually stable.
        '''
        if (len(self._state.accepted) > 0):
            (val, pn) = list(self._state.accepted)[0]
            if (len({lrn for (_, (_, _, lrn), (_ConstantPattern290_, _BoundPattern292_, _BoundPattern293_)) in self._CorrectnessLivenessReceivedEvent_0 if (_ConstantPattern290_ == 'learned') if (_BoundPattern292_ == pn) if (_BoundPattern293_ == val)}) > (self._state.f + 1)):
                return True
        return False

    def rule_cl1(self):
        ''' 
        Some proposed value is eventually chosen.
        '''
        if (len(self._state.accepted) > 0):
            (val, pn) = list(self._state.accepted)[0]
            if ((val in self._state.proposed) and (len({acc for (_, (_, _, acc), (_ConstantPattern350_, _BoundPattern352_, _BoundPattern353_)) in self._CorrectnessLivenessReceivedEvent_1 if (_ConstantPattern350_ == 'accepted') if (_BoundPattern352_ == val) if (_BoundPattern353_ == pn)}) >= math.ceil((0.5 * ((self._state.a + self._state.f) + 1))))):
                return True
        return False

    def rule_cl2(self):
        '''
        Once a value is chosen, correct learners eventually learn the value.
        '''
        if (len(self._state.accepted) > 0):
            (val, pn) = list(self._state.accepted)[0]
            if (len({lrn for (_, (_, _, lrn), (_ConstantPattern413_, _BoundPattern415_, _BoundPattern416_)) in self._CorrectnessLivenessReceivedEvent_2 if (_ConstantPattern413_ == 'learned') if (_BoundPattern415_ == pn) if (_BoundPattern416_ == val)}) >= math.ceil((0.5 * ((self._state.l - self._state.f) + 1)))):
                return True
        return False

    # def truth_to_symbol(self, truth):
    #     if truth:
    #         return '✓'
    #     return '✗'

    def checkCorrectness(self):
        print('\n', ('#' * 15), 'Correctness Verification', ('#' * 15))
        print(('-' * 55))
        print('CS1:Only a value that has been proposed may be chosen')
        print('CS2:Only a single value may be chosen')
        print('CS3:Only a chosen value may be learned by a correct learner')
        print('CL1:Some proposed value is eventually chosen')
        print('CL2:Correct learners eventually learn a chosen value')
        cs1 = self.rule_cs1()
        cs2 = self.rule_cs2()
        cs3 = self.rule_cs3()
        cl1 = self.rule_cl1()
        cl2 = self.rule_cl2()
        sat = (cs1 and cs2 and cs3 and cl1 and cl2)
        table = PrettyTable(['Correctness Condition', 'CS1', 'CS2', 'CS3', 'CL1', 'CL2'])
        lc = []
        lc.append((((('Satisfied (' + '✓') + ' / ') + '✗') + ')'))
        lc.append(self.truth_to_symbol(cs1))
        lc.append(self.truth_to_symbol(cs2))
        lc.append(self.truth_to_symbol(cs3))
        lc.append(self.truth_to_symbol(cl1))
        lc.append(self.truth_to_symbol(cl2))
        table.add_row(lc)
        print(table)
        if sat:
            print(('*' * 10), 'Correctness condition satisfied!', ('*' * 10))
        else:
            print(('*' * 12), 'Correctness condition failed!', ('*' * 12))
        print(('-' * 55), '\n')
        self._state.terminate = True

    def _CorrectnessLiveness_handler_434(self, pnumber, value, PC):
        self._state.proposed.add(value)
    _CorrectnessLiveness_handler_434._labels = None
    _CorrectnessLiveness_handler_434._notlabels = None

    def _CorrectnessLiveness_handler_452(self, value, pnumber):
        self._state.accepted.add((value, pnumber))
    _CorrectnessLiveness_handler_452._labels = None
    _CorrectnessLiveness_handler_452._notlabels = None

    def _CorrectnessLiveness_handler_470(self, r):
        self._state.accepted.clear()
        self._state.proposed.clear()
    _CorrectnessLiveness_handler_470._labels = None
    _CorrectnessLiveness_handler_470._notlabels = None

class Main(da.NodeProcess):

    def __init__(self, procimpl, forwarder, **props):
        super().__init__(procimpl, forwarder, **props)
        self._Node_ReceivedEvent_0 = []
        self._Node_ReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_0', PatternExpr_915, sources=[PatternExpr_919], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_Node_ReceivedEvent_1', PatternExpr_950, sources=[PatternExpr_954], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def run(self):
        '\n    The main method which is used to spawn Proposer, Acceptor and Learner processes \n    for the implementation. \n    Arguments for the number of proposers, acceptors, learners and byzantine processes\n    will be specified during runtime.\n    '
        f = (int(sys.argv[1]) if (len(sys.argv) > 1) else 1)
        p = (int(sys.argv[2]) if (len(sys.argv) > 2) else 4)
        a = (int(sys.argv[3]) if (len(sys.argv) > 3) else 6)
        l = (int(sys.argv[4]) if (len(sys.argv) > 4) else 4)
        leaderelect = self.new(fab.Election)
        proposers = self.new(fab.Proposer, num=p)
        acceptors = self.new(fab.Acceptor, num=a)
        learners = self.new(fab.Learner, num=l)
        correct = self.new(CorrectnessLiveness)
        mode = 2
        self._setup(leaderelect, (proposers, acceptors, p, f, mode, correct))
        self._setup(correct, (l, f, a))
        for proposer in proposers:
            self._setup(proposer, ((proposers - {proposer}), learners, acceptors, leaderelect, p, a, l, f, mode, None, correct))
        for acceptor in acceptors:
            self._setup(acceptor, (learners, (acceptors - {acceptor}), leaderelect, a, f, mode, None, correct))
        for learner in learners:
            self._setup(learner, (proposers, acceptors, (learners - {learner}), a, f, mode, None, correct))
        self._start(proposers)
        self._start(leaderelect)
        self._start(acceptors)
        self._start(learners)
        self._start(correct)
        super()._label('_st_label_907', block=False)
        learner = None

        def UniversalOpExpr_908():
            nonlocal learner
            for learner in learners:
                if (not PatternExpr_921.match_iter(self._Node_ReceivedEvent_0, _BoundPattern927_=learner)):
                    return False
            return True
        _st_label_907 = 0
        while (_st_label_907 == 0):
            _st_label_907 += 1
            if UniversalOpExpr_908():
                _st_label_907 += 1
            else:
                super()._label('_st_label_907', block=True)
                _st_label_907 -= 1
        self.send('done', to=((proposers | acceptors) | learners))
        self.send('done', to=leaderelect)
        self.send('done', to=correct)
        super()._label('_st_label_947', block=False)
        _st_label_947 = 0
        while (_st_label_947 == 0):
            _st_label_947 += 1
            if PatternExpr_956.match_iter(self._Node_ReceivedEvent_1, _BoundPattern962_=correct):
                _st_label_947 += 1
            else:
                super()._label('_st_label_947', block=True)
                _st_label_947 -= 1
